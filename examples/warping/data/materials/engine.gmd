{
  "vertex_methods" : [],
  "fragment_methods" : [
  {
    "name" : "FragmentColor",
    "source" : "


      vec3 Reflection() {
        vec3 view = normalize(gua_world_position - gua_camera_position);
        vec3 reflection_dir = normalize(reflect(view, gua_normal));
        const float pi = 3.14159265359;
        float x = 0.5 + 0.5*(2.0 * atan(reflection_dir.x/(sqrt(-reflection_dir.z*-reflection_dir.z + reflection_dir.x*reflection_dir.x) + -reflection_dir.z)))/pi;
        float y = 1.0 - acos(reflection_dir.y)/pi;
        return texture2D(sampler2D(reflection_texture), vec2(x, y)).xyz;
      }

      void FragmentColor() {

        if (style == 0) {
         gua_color = vec3(0.97,0,0);
         float r = 0.5;
         if (uvec2(0) != roughness_map)
           r = texture(sampler2D(roughness_map), gua_texcoords).r;
         gua_roughness = r/3;
         gua_metalness = 0.6;
        }
        else if (style == 1) {
         gua_color = vec3(0.955, 0.637, 0.538);
         gua_roughness = 0.3;
         gua_metalness = 0.8;
        }
        else {
         gua_color = vec3(0.913, 0.921, 0.925);
         gua_roughness = 0.3;
         gua_metalness = 0.7;
        }

        gua_emissivity = 0;

        const float r_ind = 1.5;
        const float Rs = ((1.0 - r_ind) * (1.0 - r_ind)) / ((1.0 + r_ind) * (1.0 + r_ind));
        // Schlick's approximation
        float fresnel = Rs + (1.0 - Rs) *
                        pow((1.0 - abs(dot(gua_normal,
                                           normalize(gua_world_position - gua_camera_position)))), 5.0);
        gua_alpha = clamp(opacity + mix(0.0, fresnel, 0.5), 0.0, 1.0);
        //gua_alpha = fresnel;

        gua_color = mix(gua_color, Reflection(), 0.8*fresnel+0.2);

        // highlight
        float hl_intensity = mix(0.0, clamp(fresnel+0.1, 0.0, 0.9), highlight);
        gua_color = mix(gua_color, vec3(1,1,0), hl_intensity);
        gua_emissivity = hl_intensity;

        // see-through
        const float feather = 0.04;
        const float min_alpha = (style == 1) ? 0.5 : 0.05;
        if (cut_rad > 0.001) {
          const vec3 p = gua_varying_world_position;
          float cut_dist = length((cut_pos-p)-(dot(cut_pos - p, cut_n)*cut_n));
          gua_alpha = mix(min_alpha,
                          gua_alpha * clamp(min_alpha + (cut_dist-cut_rad)/feather, 0.0, 1.0),
                          cut_dist >= cut_rad);
        }

        // fade out
        const float fade_dist = 0.15;
        gua_alpha *= smoothstep(0.0, 1.0, gl_FragCoord.z / gl_FragCoord.w / fade_dist);

        // model opacity
        gua_alpha *= opacity_total;
      }",
    "uniforms" : [
      {
        "name" : "style",
        "type" : "int",
        "value" : "0"
      },
      {
        "name" : "highlight",
        "type" : "float",
        "value" : "0.0"
      },
      {
        "name" : "opacity",
        "type" : "float",
        "value" : "1.0"
      },
      {
        "name" : "opacity_total",
        "type" : "float",
        "value" : "1.0"
      },
      {
        "name" : "cut_pos",
        "type" : "vec3",
        "value" : "(0.0 0.0 0.0)"
      },
      {
        "name" : "cut_n",
        "type" : "vec3",
        "value" : "(1.0 0.0 0.0)"
      },
      {
        "name" : "cut_rad",
        "type" : "float",
        "value" : "0.0"
      },
      {
        "name" : "roughness_map",
        "type" : "sampler2D",
        "value" : "0"
      },
      {
        "name" : "reflection_texture",
        "type" : "sampler2D",
        "value" : "0"
      }
    ]
  }
  ]
}

