

/**
 * Ray-box intersection using IEEE numerical properties to ensure that the
 * test is both robust and efficient, as described in:
 *
 *      Amy Williams, Steve Barrus, R. Keith Morley, and Peter Shirley
 *      "An Efficient and Robust Ray-Box Intersection Algorithm"
 *      Journal of graphics tools, 10(1):49-54, 2005
 *
 */

/* http://ompf.org/ray/ray_box.html */
//bool_t ray_box_intersects_slabs_geimer_mueller(const aabb_t &box, const ray_t &ray) {
bool
ray_box_intersection(in ray    r,
                     in vec3   bbmin,
                     in vec3   bbmax,
                     out float tmin,
                     out float tmax)
{
    float l1 = (bbmin.x - r.origin.x) * r.direction_rec.x;
    float l2 = (bbmax.x - r.origin.x) * r.direction_rec.x;
    tmin = min(l1,l2);
    tmax = max(l1,l2);

    l1   = (bbmin.y - r.origin.y) * r.direction_rec.y;
    l2   = (bbmax.y - r.origin.y) * r.direction_rec.y;
    tmin = max(min(l1,l2), tmin);
    tmax = min(max(l1,l2), tmax);
        
    l1   = (bbmin.z - r.origin.z) * r.direction_rec.z;
    l2   = (bbmax.z - r.origin.z) * r.direction_rec.z;
    tmin = max(min(l1,l2), tmin);
    tmax = min(max(l1,l2), tmax);

    //return ((lmax > 0.f) & (lmax >= lmin));
    //return ((lmax > 0.f) & (lmax > lmin));
    return ((tmin > 0.0) && (tmax > tmin));
}

bool
ray_plane_intersection(in  ray   r,
                       in  vec4  p,
                       out float t)
{
    t = 0.0;
    float nd = dot(p.xyz, r.direction);
    if (abs(nd) < epsilon) return false;
    t = -(p.w + dot(p.xyz, r.origin.xyz)) / nd;

    return t > 0.0;
}

