
bool
volume_ray_setup_ots(in vec3 os_ray_entry,
out ray r,
out vec2 t,
out float d)
{
    t = vec2(float_max, -float_max);

    const vec3 object_to_ots = scale_obj_to_tex;
    const vec3 ots_bbox_min = volume_bbox_min.xyz * object_to_ots;
    const vec3 ots_bbox_max = volume_bbox_max.xyz * object_to_ots;

    const mat4 gua_invers_model_matrix = inverse(gua_model_matrix);
    const vec3 os_origin = (gua_invers_model_matrix * vec4(gua_camera_position, 1.0)).xyz;
    const vec3 os_exit = os_ray_entry;//v_in.ray_entry_os.xyz;
    const vec3 os_seg = os_exit - os_origin;

    const vec3 ots_origin = os_origin * object_to_ots;
    const vec3 ots_exit = os_exit * object_to_ots;
    const vec3 ots_seg = ots_exit - ots_origin;
    const vec3 ots_dir = normalize(ots_seg);

    d = (length(ots_seg) * sampling_distance.x) / length(os_seg);

    r = make_safe_ray(ots_origin, ots_dir /** s*/);

    float t_entry = -1.0;
    float t_exit = -1.0;
    float t_near = -1.0;

    mat4 gua_transp_model_matrix = transpose(gua_model_matrix);

    vec4 ts_near_plane = (gua_transp_model_matrix * near_plane) / vec4(object_to_ots, 1.0); // inverse transpose of the scale
    ts_near_plane /= length(ts_near_plane.xyz);

    ray_box_intersection(r, ots_bbox_min, ots_bbox_max, t_entry, t_exit);
    ray_plane_intersection(r, ts_near_plane, t_near);

    t_entry = max(t_entry, t_near);
    t = vec2(t_entry, t_exit);

#if 1

    vec3 gua_object_volume_position_front = (r.origin + t.x * r.direction);// / (scale_obj_to_tex.xyz);
    vec3 gua_world_volume_position_front = (gua_model_matrix * vec4(gua_object_volume_position_front, 1.0)).xyz;
    vec3 gua_world_volume_position_back = (gua_model_matrix * vec4(os_ray_entry, 1.0)).xyz;

    float d_gbuffer_z = texture2D(gua_get_float_sampler(gua_depth_gbuffer_in), gua_get_quad_coords()).x;
    float d_volume_back_z = get_depth_z(gua_world_volume_position_back);
    float d_volume_front_z = get_depth_z(gua_world_volume_position_front);

    float d_gbuffer = abs((get_depth_linear(d_gbuffer_z)));
    float d_volume_back = abs((get_depth_linear(d_volume_back_z)));
    float d_volume_front = abs((get_depth_linear(d_volume_front_z)));

    if (d_gbuffer < d_volume_front){ // geometry in front of
        t.x = t.y - 1.0;//d_volume_front better?
        return false;
    }

    if (d_gbuffer < d_volume_back){ // there is geometry between inside

        float d_abs = d_volume_back - d_volume_front;
        float t_abs = t.y - t.x;
        float norm_dg = 0.0;
        if (d_abs > 0.000001){
            norm_dg = (d_gbuffer - d_volume_front) / (d_abs);
        }
        t.y -= (t_abs * (1.0 - norm_dg));
    }
#endif

    return t.x < t.y;

}

bool
vvolume_ray_setup_ots(in vec3 os_ray_entry,
out ray r,
out vec2 t,
out float d)

{

    t = vec2(float_max, -float_max);

    const vec3 object_to_ots = scale_obj_to_tex * vtex_volume.texcoord_scale;

    const vec3 ots_bbox_min = volume_bbox_min.xyz * object_to_ots;
    const vec3 ots_bbox_max = volume_bbox_max.xyz * object_to_ots;

    const mat4 gua_invers_model_matrix = inverse(gua_model_matrix);
    const vec3 os_origin = (gua_invers_model_matrix * vec4(gua_camera_position, 1.0)).xyz;
    const vec3 os_exit = os_ray_entry;//v_in.ray_entry_os.xyz;
    const vec3 os_seg = os_exit - os_origin;

    const vec3 ots_origin = os_origin * object_to_ots;
    const vec3 ots_exit = os_exit * object_to_ots;
    const vec3 ots_seg = ots_exit - ots_origin;
    const vec3 ots_dir = normalize(ots_seg);

    d = (length(ots_seg) * sampling_distance.x) / length(os_seg);
    r = make_safe_ray(ots_origin, ots_dir /** s*/);

    float t_entry = -1.0;
    float t_exit = -1.0;
    float t_near = -1.0;

    mat4 gua_transp_model_matrix = transpose(gua_model_matrix);
    vec4 ts_near_plane = (gua_transp_model_matrix * near_plane) / vec4(object_to_ots, 1.0); // inverse transpose of the scale
    ts_near_plane /= length(ts_near_plane.xyz);

    ray_box_intersection(r, ots_bbox_min, ots_bbox_max, t_entry, t_exit);
    ray_plane_intersection(r, ts_near_plane, t_near);

    t_entry = max(t_entry, t_near);
    t = vec2(t_entry, t_exit);

#if 1

    vec3 gua_object_volume_position_front = (r.origin + t.x * r.direction) / (scale_obj_to_tex.xyz);
    vec3 gua_world_volume_position_front = (gua_model_matrix * vec4(gua_object_volume_position_front, 1.0)).xyz;
    vec3 gua_world_volume_position_back = (gua_model_matrix * vec4(os_ray_entry, 1.0)).xyz;

    float d_gbuffer_z = texture2D(gua_get_float_sampler(gua_depth_gbuffer_in), gua_get_quad_coords()).x;
    float d_volume_back_z = get_depth_z(gua_world_volume_position_back);
    float d_volume_front_z = get_depth_z(gua_world_volume_position_front);

    float d_gbuffer = abs((get_depth_linear(d_gbuffer_z)));
    float d_volume_back = abs((get_depth_linear(d_volume_back_z)));
    float d_volume_front = abs((get_depth_linear(d_volume_front_z)));

    if (d_gbuffer < d_volume_front){ // geometry in front of
        t.x = t.y - 1.0;//d_volume_front better?
        return false;
    }

    if (d_gbuffer < d_volume_back){ // there is geometry between inside

        float d_abs = d_volume_back - d_volume_front;
        float t_abs = t.y - t.x;
        float norm_dg = 0.0;
        if (d_abs > 0.000001){
            norm_dg = (d_gbuffer - d_volume_front) / (d_abs);
        }
        t.y -= (t_abs * (1.0 - norm_dg));
    }

#endif

    return t.x < t.y;

}