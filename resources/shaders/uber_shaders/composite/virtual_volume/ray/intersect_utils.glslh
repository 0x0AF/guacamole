
#ifndef SCM_LDATA_RAY_INTERSECT_UTILS_GLSLH_INCLUDED
#define SCM_LDATA_RAY_INTERSECT_UTILS_GLSLH_INCLUDED

#include </scm/data/ray/ray.glslh>

/**
 * Ray-box intersection using IEEE numerical properties to ensure that the
 * test is both robust and efficient, as described in:
 *
 *      Amy Williams, Steve Barrus, R. Keith Morley, and Peter Shirley
 *      "An Efficient and Robust Ray-Box Intersection Algorithm"
 *      Journal of graphics tools, 10(1):49-54, 2005
 *
 */
#if 0
bool
ray_box_intersection(in ray    r,
                     in vec3   bbmin,
                     in vec3   bbmax,
                     out float tmin,
                     out float tmax)
{
    float tymin = 0.0;
    float tymax = 0.0;
    float tzmin = 0.0;
    float tzmax = 0.0;

    if (r.direction_rec.x >= 0.0) {
        tmin = (bbmin.x - r.origin.x) * r.direction_rec.x;
        tmax = (bbmax.x - r.origin.x) * r.direction_rec.x;
    }
    else {
        tmin = (bbmax.x - r.origin.x) * r.direction_rec.x;
        tmax = (bbmin.x - r.origin.x) * r.direction_rec.x;
    }

    if (r.direction_rec.y >= 0.0) {
        tymin = (bbmin.y - r.origin.y) * r.direction_rec.y;
        tymax = (bbmax.y - r.origin.y) * r.direction_rec.y;
    }
    else {
        tymin = (bbmax.y - r.origin.y) * r.direction_rec.y;
        tymax = (bbmin.y - r.origin.y) * r.direction_rec.y;
    }

    if ((tmin > tymax) || (tymin > tmax)) return false;

    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;
    
    if (r.direction_rec.z >= 0.0) {
        tzmin = (bbmin.z - r.origin.z) * r.direction_rec.z;
        tzmax = (bbmax.z - r.origin.z) * r.direction_rec.z;
    }
    else {
        tzmin = (bbmax.z - r.origin.z) * r.direction_rec.z;
        tzmax = (bbmin.z - r.origin.z) * r.direction_rec.z;
    }

    if ((tmin > tzmax) || (tzmin > tmax)) return false;

    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax;

    return ((tmin > 0.0) && (tmax > tmin));
}
#else
/* http://ompf.org/ray/ray_box.html */
//bool_t ray_box_intersects_slabs_geimer_mueller(const aabb_t &box, const ray_t &ray) {
bool
ray_box_intersection(in ray    r,
                     in vec3   bbmin,
                     in vec3   bbmax,
                     out float tmin,
                     out float tmax)
{
    float l1 = (bbmin.x - r.origin.x) * r.direction_rec.x;
    float l2 = (bbmax.x - r.origin.x) * r.direction_rec.x;
    tmin = min(l1,l2);
    tmax = max(l1,l2);

    l1   = (bbmin.y - r.origin.y) * r.direction_rec.y;
    l2   = (bbmax.y - r.origin.y) * r.direction_rec.y;
    tmin = max(min(l1,l2), tmin);
    tmax = min(max(l1,l2), tmax);
        
    l1   = (bbmin.z - r.origin.z) * r.direction_rec.z;
    l2   = (bbmax.z - r.origin.z) * r.direction_rec.z;
    tmin = max(min(l1,l2), tmin);
    tmax = min(max(l1,l2), tmax);

    //return ((lmax > 0.f) & (lmax >= lmin));
    //return ((lmax > 0.f) & (lmax > lmin));
    return ((tmin > 0.0) && (tmax > tmin));
}
#endif

bool
ray_plane_intersection(in  ray   r,
                       in  vec4  p,
                       out float t)
{
    t = 0.0;
    float nd = dot(p.xyz, r.direction);
    if (abs(nd) < epsilon) return false;
    t = -(p.w + dot(p.xyz, r.origin.xyz)) / nd;

    return t > 0.0;
}

#endif // SCM_LDATA_RAY_INTERSECT_UTILS_GLSLH_INCLUDED
