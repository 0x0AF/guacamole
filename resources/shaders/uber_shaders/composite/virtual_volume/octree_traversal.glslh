
#ifndef SCM_LDATA_VVOLUME_RAY_CAST_OCTREE_TRAVERSAL_GLSLH_INCLUDED
#define SCM_LDATA_VVOLUME_RAY_CAST_OCTREE_TRAVERSAL_GLSLH_INCLUDED

#include </scm/data/vtexture/vtexture.glslh>

struct ray_cast_trav_info {
    uvec4   vpage_index_data;
    int     vpage_level;
    vec3    vpage_coord;
    vec3    octree_node_pos;
    vec3    octree_nodes_per_level;
    vec3    ptex_coord_trilinear; // physical texture coordinate, trilinear
}; // struct quadtree_trav_info

void ray_cast_octree_traverse(in vtexture3D          vtex,       // virtual texture decriptor struct
                              in vec3                vtex_coord, // virtual texture coordinate
                              in float               target_lod,
                              out ray_cast_trav_info trav_info)
{
    //precision highp   float;
    //precision mediump int;

    float target_level_ceil = ceil(target_lod);
    
    // TODO test with smaller integer type or float type...!
    // traversal termination variables
    int mlvl = int(target_level_ceil);
    int clvl = 0;

    //vtex_coord = clamp(vtex_coord, vec3(0.0), vec3(1.0));

    // initialize and sample the root node
    vec3  node_spos = 2.0 * vtex_coord;
    int   node_off  = int(floor(node_spos.x)) + 2 * int(floor(node_spos.y)) + 4 * int(floor(node_spos.z));
    uvec4 idx_data  = uvec4(texelFetch(vtex.octree_enc_00, node_off).xy,
                            texelFetch(vtex.octree_enc_01, node_off).xy);

    uint is_leaf = idx_data.w & 0x8000u;
    
    // traversal
    while (   !(is_leaf > 0) // we are not at a leaf
           && (clvl < mlvl))    // we are still over our target lod
    {
        int buff_no = node_off + 8 * int(idx_data.w);
        idx_data.xy = texelFetch(vtex.octree_enc_00, buff_no).xy;
        idx_data.zw = texelFetch(vtex.octree_enc_01, buff_no).xy;
        node_spos   = 2.0 * fract(node_spos);
        node_off    =       int(floor(node_spos.x))
                      + 2 * int(floor(node_spos.y))
                      + 4 * int(floor(node_spos.z));

        is_leaf = idx_data.w & 0x8000u;

        ++clvl;
    }

    trav_info.vpage_index_data = idx_data;
    trav_info.vpage_level      = clvl;

    trav_info.octree_nodes_per_level = vec3(float(1 << clvl));
    trav_info.octree_node_pos        = floor(vtex_coord * trav_info.octree_nodes_per_level);

    // scale current brick space sample position into brick core space
    trav_info.vpage_coord          = vtex.page_border_size + node_spos * 0.5 * vtex.page_core_size;
    trav_info.ptex_coord_trilinear = vtex.page_atlas.size_pages_rec * (vec3(idx_data.xyz) + trav_info.vpage_coord);
}

void ray_cast_octree_traverse_blend(in vtexture3D          vtex,       // virtual texture decriptor struct
                                    in vec3                vtex_coord, // virtual texture coordinate
                                    in float               target_lod,
                                    out ray_cast_trav_info trav_info_leaf,
							        out ray_cast_trav_info trav_info_parent)
{
    //precision highp   float;
    //precision mediump int;

    float target_level_ceil = ceil(target_lod);
    
    // TODO test with smaller integer type or float type...!
    // traversal termination variables
    int mlvl = int(target_level_ceil);
    int clvl = 0;

    //vtex_coord = clamp(vtex_coord, vec3(0.0), vec3(1.0));

    // initialize and sample the root node
    vec3  node_spos = 2.0 * vtex_coord;
    int   node_off  = int(floor(node_spos.x)) + 2 * int(floor(node_spos.y)) + 4 * int(floor(node_spos.z));
    uvec4 idx_data  = uvec4(texelFetch(vtex.octree_enc_00, node_off).xy,
                            texelFetch(vtex.octree_enc_01, node_off).xy);

	vec3  par_node_spos = node_spos;
	uvec4 par_idx_data  = idx_data;
    
	uint is_leaf = idx_data.w & 0x8000u;

    // traversal
    while (   !(is_leaf > 0u) // we are not at a leaf
           && (clvl < mlvl))    // we are still over our target lod
    {
		par_node_spos = node_spos;
		par_idx_data  = idx_data;
		
        int buff_no = node_off + 8 * int(idx_data.w);
        idx_data.xy = texelFetch(vtex.octree_enc_00, buff_no).xy;
        idx_data.zw = texelFetch(vtex.octree_enc_01, buff_no).xy;
        node_spos   = 2.0 * fract(node_spos);
        node_off    =       int(floor(node_spos.x))
                      + 2 * int(floor(node_spos.y))
                      + 4 * int(floor(node_spos.z));

		is_leaf = idx_data.w & 0x8000u;

        ++clvl;
    }

    trav_info_leaf.vpage_index_data = idx_data;
    trav_info_leaf.vpage_level      = clvl;

    trav_info_leaf.octree_nodes_per_level = vec3(float(1 << trav_info_leaf.vpage_level));
    trav_info_leaf.octree_node_pos        = floor(vtex_coord * trav_info_leaf.octree_nodes_per_level);

    // scale current brick space sample position into brick core space
    trav_info_leaf.vpage_coord          = vtex.page_border_size + node_spos * 0.5 * vtex.page_core_size;
    trav_info_leaf.ptex_coord_trilinear = vtex.page_atlas.size_pages_rec * (vec3(idx_data.xyz) + trav_info_leaf.vpage_coord);

    trav_info_parent.vpage_index_data = par_idx_data;
    trav_info_parent.vpage_level      = clvl - 1;

    trav_info_parent.octree_nodes_per_level = vec3(float(1 << trav_info_parent.vpage_level));
    trav_info_parent.octree_node_pos        = floor(vtex_coord * trav_info_parent.octree_nodes_per_level);

    // scale current brick space sample position into brick core space
    trav_info_parent.vpage_coord          = vtex.page_border_size + par_node_spos * 0.5 * vtex.page_core_size;
    trav_info_parent.ptex_coord_trilinear = vtex.page_atlas.size_pages_rec * (vec3(par_idx_data.xyz) + trav_info_parent.vpage_coord);
}

#endif // SCM_LDATA_VVOLUME_RAY_CAST_OCTREE_TRAVERSAL_GLSLH_INCLUDED
